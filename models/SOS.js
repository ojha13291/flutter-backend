const mongoose = require('mongoose');

const SOSSchema = new mongoose.Schema({
  touristId: {
    type: String,
    required: true,
    index: true,
    trim: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  // Emergency alert details
  alertType: {
    type: String,
    enum: ['PANIC', 'MEDICAL', 'ACCIDENT', 'CRIME', 'NATURAL_DISASTER', 'LOST', 'OTHER'],
    required: true
  },
  
  severity: {
    type: String,
    enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    required: true,
    default: 'HIGH'
  },
  
  status: {
    type: String,
    enum: ['ACTIVE', 'ACKNOWLEDGED', 'RESPONDING', 'RESOLVED', 'FALSE_ALARM', 'CANCELLED'],
    default: 'ACTIVE',
    index: true
  },
  
  // Location information at time of SOS
  location: {
    type: {
      type: String,
      enum: ['Point'],
      required: true,
      default: 'Point'
    },
    coordinates: {
      type: [Number], // [longitude, latitude]
      required: true
    }
  },
  
  // Reverse geocoded address
  address: {
    formatted: String,
    street: String,
    city: String,
    state: String,
    country: String,
    postalCode: String
  },
  
  // Additional context and description
  description: {
    type: String,
    maxlength: 500,
    trim: true
  },
  
  // Automatic device information
  deviceInfo: {
    platform: String,        // iOS, Android, Web
    batteryLevel: Number,     // 0-100
    signalStrength: Number,   // 0-100
    appVersion: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  },
  
  // Emergency response details
  responseDetails: {
    acknowledgedAt: Date,
    acknowledgedBy: String,
    respondingAt: Date,
    respondingUnits: [String], // Police, Ambulance, Fire, etc.
    estimatedArrival: Date
  },
  
  // Resolution details
  resolvedAt: Date,
  resolutionNotes: {
    type: String,
    maxlength: 1000
  },
  resolutionType: {
    type: String,
    enum: ['SELF_RESOLVED', 'HELP_ARRIVED', 'FALSE_ALARM', 'TRANSFERRED', 'CANCELLED', 'OTHER']
  },
  
  // Notifications sent for this SOS
  notificationsSent: [{
    recipientType: {
      type: String,
      enum: ['EMERGENCY_CONTACT', 'LOCAL_AUTHORITIES', 'EMBASSY', 'HOTEL', 'GUIDE', 'INSURANCE', 'MEDICAL']
    },
    recipient: String,        // Name or identifier
    contact: String,          // Phone, email, etc.
    method: {
      type: String,
      enum: ['SMS', 'EMAIL', 'CALL', 'PUSH_NOTIFICATION', 'IN_APP', 'WHATSAPP']
    },
    sentAt: {
      type: Date,
      default: Date.now
    },
    status: {
      type: String,
      enum: ['SENT', 'DELIVERED', 'FAILED', 'ACKNOWLEDGED', 'RESPONDED']
    },
    attempts: {
      type: Number,
      default: 1
    }
  }],
  
  // Emergency escalation
  escalation: {
    level: {
      type: Number,
      min: 1,
      max: 5,
      default: 1
    },
    escalatedAt: Date,
    escalatedTo: String,
    reason: String
  },
  
  // Emergency code for first responders
  emergencyCode: {
    type: String,
    unique: true,
    sparse: true  // Allow multiple null values
  },
  
  // Medical information relevant to the emergency
  medicalInfo: {
    bloodType: String,
    allergies: [String],
    medications: [String],
    conditions: [String],
    insuranceInfo: String
  },
  
  // Metadata
  autoGenerated: {
    type: Boolean,
    default: false
  },
  
  priority: {
    type: Number,
    min: 1,
    max: 10,
    default: 8
  },
  
  // Tracking for analytics
  responseTime: Number,      // Time to acknowledge in seconds
  resolutionTime: Number,    // Time to resolve in seconds
  
  // Related incidents
  relatedIncidents: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'SOS'
  }]
}, {
  timestamps: true,
  toJSON: { 
    virtuals: true,
    transform: function(doc, ret) {
      ret.latitude = ret.location.coordinates[1];
      ret.longitude = ret.location.coordinates[0];
      return ret;
    }
  },
  toObject: { virtuals: true }
});

// Indexes for performance and geospatial queries
SOSSchema.index({ location: '2dsphere' });
SOSSchema.index({ touristId: 1, createdAt: -1 });
SOSSchema.index({ status: 1, severity: 1, createdAt: -1 });
SOSSchema.index({ userId: 1, status: 1 });
SOSSchema.index({ alertType: 1, status: 1 });
SOSSchema.index({ createdAt: -1 });

// Virtual properties
SOSSchema.virtual('isActive').get(function() {
  return ['ACTIVE', 'ACKNOWLEDGED', 'RESPONDING'].includes(this.status);
});

SOSSchema.virtual('timeElapsed').get(function() {
  return Date.now() - this.createdAt.getTime();
});

SOSSchema.virtual('coordinates').get(function() {
  return {
    latitude: this.location.coordinates[1],
    longitude: this.location.coordinates[0]
  };
});

// Instance methods
SOSSchema.methods.acknowledge = function(acknowledgedBy) {
  this.status = 'ACKNOWLEDGED';
  this.responseDetails.acknowledgedAt = new Date();
  this.responseDetails.acknowledgedBy = acknowledgedBy;
  this.responseTime = (this.responseDetails.acknowledgedAt - this.createdAt) / 1000;
  return this.save();
};

SOSSchema.methods.markResponding = function(units = []) {
  this.status = 'RESPONDING';
  this.responseDetails.respondingAt = new Date();
  this.responseDetails.respondingUnits = units;
  return this.save();
};

SOSSchema.methods.resolve = function(resolutionType, notes) {
  this.status = 'RESOLVED';
  this.resolvedAt = new Date();
  this.resolutionType = resolutionType;
  this.resolutionNotes = notes;
  this.resolutionTime = (this.resolvedAt - this.createdAt) / 1000;
  return this.save();
};

SOSSchema.methods.cancel = function(reason) {
  this.status = 'CANCELLED';
  this.resolvedAt = new Date();
  this.resolutionType = 'CANCELLED';
  this.resolutionNotes = reason;
  return this.save();
};

SOSSchema.methods.escalate = function(reason) {
  this.escalation.level += 1;
  this.escalation.escalatedAt = new Date();
  this.escalation.reason = reason;
  
  // Increase priority
  this.priority = Math.min(this.priority + 2, 10);
  
  return this.save();
};

SOSSchema.methods.addNotification = function(notificationData) {
  this.notificationsSent.push(notificationData);
  return this.save();
};

// Static methods for finding SOS alerts
SOSSchema.statics.findActiveAlerts = function() {
  return this.find({
    status: { $in: ['ACTIVE', 'ACKNOWLEDGED', 'RESPONDING'] }
  }).sort({ createdAt: -1 });
};

SOSSchema.statics.findByLocation = function(longitude, latitude, radiusInMeters = 5000) {
  return this.find({
    location: {
      $near: {
        $geometry: {
          type: 'Point',
          coordinates: [longitude, latitude]
        },
        $maxDistance: radiusInMeters
      }
    }
  });
};

SOSSchema.statics.findCriticalAlerts = function() {
  return this.find({
    severity: 'CRITICAL',
    status: { $in: ['ACTIVE', 'ACKNOWLEDGED', 'RESPONDING'] }
  }).sort({ createdAt: -1 });
};

SOSSchema.statics.findByUser = function(userId, limit = 10) {
  return this.find({ userId })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate('userId', 'fullName touristId mobileNumber');
};

// Pre-save middleware
SOSSchema.pre('save', function(next) {
  // Generate emergency code if not exists
  if (!this.emergencyCode && this.isNew) {
    this.emergencyCode = this.generateEmergencyCode();
  }
  
  // Auto-escalate based on time
  if (this.isActive && this.timeElapsed > 900000) { // 15 minutes
    this.escalation.level = Math.max(this.escalation.level, 2);
  }
  
  next();
});

// Pre-save method to generate emergency code
SOSSchema.methods.generateEmergencyCode = function() {
  const prefix = this.alertType.substring(0, 2).toUpperCase();
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 5).toUpperCase();
  return `${prefix}-${timestamp}-${random}`;
};

// Post-save middleware for logging
SOSSchema.post('save', function(doc) {
  console.log(`SOS Alert ${doc.status}: ${doc._id} for tourist ${doc.touristId}`);
});

module.exports = mongoose.model('SOS', SOSSchema);
